PUSH-( ns examples.program39 POP-ALL

PUSH-( defrecord Node PUSH-[ keys children leaf? POP-ALL

PUSH-( defn create-node PUSH-[ leaf? POP
  PUSH-( ->Node PUSH-[ POP PUSH-[ POP leaf? POP-ALL

PUSH-( def t 3 POP-ALL

PUSH-( defn split-child PUSH-[ parent idx child POP
  PUSH-( let PUSH-[
    mid PUSH-( quot PUSH-( count PUSH-( :keys child POP POP 2 POP
    mid-key PUSH-( nth PUSH-( :keys child POP mid POP
    left-keys PUSH-( subvec PUSH-( :keys child POP 0 mid POP
    right-keys PUSH-( subvec PUSH-( :keys child POP PUSH-( inc mid POP PUSH-( count PUSH-( :keys child POP POP POP
    new-node PUSH-( ->Node right-keys
                    PUSH-( if PUSH-( :leaf? child POP
                      PUSH-[ POP
                      PUSH-( subvec PUSH-( :children child POP PUSH-( inc mid POP PUSH-( count PUSH-( :children child POP POP POP POP
                    PUSH-( :leaf? child POP POP
    updated-child PUSH-( assoc child
                        :keys left-keys
                        :children PUSH-( if PUSH-( :leaf? child POP
                                    PUSH-[ POP
                                    PUSH-( subvec PUSH-( :children child POP 0 PUSH-( inc mid POP POP POP POP
  POP
    PUSH-( assoc parent
          :keys PUSH-( vec PUSH-( concat PUSH-( take idx PUSH-( :keys parent POP POP
                              PUSH-[ mid-key POP
                              PUSH-( drop idx PUSH-( :keys parent POP POP POP POP
          :children PUSH-( vec PUSH-( concat PUSH-( take idx PUSH-( :children parent POP POP
                                  PUSH-[ updated-child new-node POP
                                  PUSH-( drop PUSH-( inc idx POP PUSH-( :children parent POP POP POP POP POP-ALL

PUSH-( defn insert-non-full PUSH-[ node k POP
  PUSH-( if PUSH-( :leaf? node POP
    PUSH-( let PUSH-[
      new-keys PUSH-( vec PUSH-( sort PUSH-( conj PUSH-( :keys node POP k POP POP POP
    POP
      PUSH-( assoc node :keys new-keys POP-ALL
    PUSH-( let PUSH-[
      idx PUSH-( count PUSH-( take-while PUSH-( fn PUSH-[ x POP PUSH-( < x k POP POP PUSH-( :keys node POP POP POP
      child PUSH-( nth PUSH-( :children node POP idx POP
      updated-child PUSH-( if PUSH-( >= PUSH-( count PUSH-( :keys child POP POP PUSH-( - PUSH-( * 2 t POP 1 POP POP
                      PUSH-( let PUSH-[
                        split-parent PUSH-( split-child node idx child POP
                        new-idx PUSH-( if PUSH-( > k PUSH-( nth PUSH-( :keys split-parent POP idx POP POP PUSH-( inc idx POP idx POP
                      POP
                        PUSH-( insert-non-full PUSH-( nth PUSH-( :children split-parent POP new-idx POP k POP-ALL
                      PUSH-( insert-non-full child k POP POP
    POP
      PUSH-( if PUSH-( identical? updated-child child POP
        node
        PUSH-( assoc node :children PUSH-( assoc PUSH-( :children node POP idx updated-child POP POP POP-ALL

PUSH-( defn b-tree-insert PUSH-[ root k POP
  PUSH-( if PUSH-( nil? root POP
    PUSH-( ->Node PUSH-[ k POP PUSH-[ POP true POP
    PUSH-( if PUSH-( >= PUSH-( count PUSH-( :keys root POP POP PUSH-( - PUSH-( * 2 t POP 1 POP POP
      PUSH-( let PUSH-[
        new-root PUSH-( ->Node PUSH-[ POP PUSH-[ root POP false POP
        split-root PUSH-( split-child new-root 0 root POP
      POP
        PUSH-( insert-non-full split-root k POP-ALL
      PUSH-( insert-non-full root k POP POP-ALL

PUSH-( defn b-tree-search PUSH-[ node k POP
  PUSH-( when node
    PUSH-( let PUSH-[
      idx PUSH-( count PUSH-( take-while PUSH-( fn PUSH-[ x POP PUSH-( < x k POP POP PUSH-( :keys node POP POP POP
    POP
      PUSH-( cond
        PUSH-( and PUSH-( < idx PUSH-( count PUSH-( :keys node POP POP POP
             PUSH-( = k PUSH-( nth PUSH-( :keys node POP idx POP POP POP
        true

        PUSH-( :leaf? node POP
        false

        :else
        PUSH-( b-tree-search PUSH-( nth PUSH-( :children node POP idx POP k POP-ALL

PUSH-( defn split-node PUSH-[ node POP
  PUSH-( let PUSH-[
    mid PUSH-( quot PUSH-( count PUSH-( :keys node POP POP 2 POP
    mid-key PUSH-( nth PUSH-( :keys node POP mid POP
    left PUSH-( ->Node PUSH-( subvec PUSH-( :keys node POP 0 mid POP
                PUSH-( if PUSH-( :leaf? node POP
                  PUSH-[ POP
                  PUSH-( subvec PUSH-( :children node POP 0 PUSH-( inc mid POP POP POP
                PUSH-( :leaf? node POP POP
    right PUSH-( ->Node PUSH-( subvec PUSH-( :keys node POP PUSH-( inc mid POP PUSH-( count PUSH-( :keys node POP POP POP
                 PUSH-( if PUSH-( :leaf? node POP
                   PUSH-[ POP
                   PUSH-( subvec PUSH-( :children node POP PUSH-( inc mid POP PUSH-( count PUSH-( :children node POP POP POP POP
                 PUSH-( :leaf? node POP POP
  POP
    PUSH-{ :mid-key mid-key :left left :right right POP-ALL