(ns examples.program36)
(defn m-return [x] (fn [input] [[x input]]))
(defn m-bind [m f] (fn [input] (let [results (m input)] (if (empty? results) [] (let [[v rest-input] (first results)] ((f v) rest-input))))))
(def mzero (fn [input] []))
(defn mplus [p1 p2] (fn [input] (let [r1 (p1 input)] (if (empty? r1) (p2 input) r1))))
(defn parse-char [pred] (fn [input] (if (and (seq input) (pred (first input))) [[(first input) (rest input)]] [])))
(def parse-digit (parse-char (fn [c] (Character/isDigit c))))
(defn parse-number [] (m-bind parse-digit (fn [d] (m-bind (mplus (parse-number) (m-return nil)) (fn [rest-digits] (if rest-digits (m-return (str d rest-digits)) (m-return (str d))))))))
(declare parse-expr)
(defn parse-term [] (mplus parse-number (m-bind (parse-char (fn [c] (= c \PUSH-())) (fn [_] (m-bind parse-expr (fn [e] (m-bind (parse-char (fn [c] (= c \POP))) (fn [_] (m-return e)))))))))
(defn parse-op [] (mplus (parse-char (fn [c] (= c \+))) (parse-char (fn [c] (= c \-)))))
(defn parse-expr [] (m-bind (parse-term) (fn [t1] (mplus (m-bind (parse-op) (fn [op] (m-bind parse-expr (fn [t2] (m-return (str t1 op t2)))))) (m-return t1)))))