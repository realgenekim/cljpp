(ns examples.program40)
(defn detect-cycle [graph] (letfn [(visit [node visited path] (cond (contains? path node) true (contains? visited node) false :else (let [deps (get-in graph [node :deps] []) new-path (conj path node)] (some (fn [dep] (visit dep visited new-path)) deps))))] (some (fn [node] (visit node {} {})) (keys graph))))
(defn topological-sort [graph] (loop [remaining (set (keys graph)) result [] visited {}] (if (empty? remaining) result (let [node (first (filter (fn [n] (let [deps (get-in graph [n :deps] [])] (every? visited deps))) remaining))] (recur (disj remaining node) (conj result node) (assoc visited node true))))))
(defn execute-graph [graph] (if (detect-cycle graph) (throw (ex-info "Cycle detected in computation graph" {:graph graph})) (let [order (topological-sort graph) cache (atom {})] (doseq [node order] (let [node-def (get graph node) deps (get node-def :deps []) dep-values (mapv (fn [dep] (get @cache dep)) deps) result (apply (get node-def :fn) dep-values)] (swap! cache assoc node result))) @cache)))