(ns examples.program39)
(defrecord Node [keys children leaf?])
(defn create-node [leaf?] (->Node [] [] leaf?))
(defn create-btree [t] {:root (create-node true), :t t})
(defn split-child [parent idx child t] (let [mid (quot (count (:keys child)) 2) left-keys (subvec (:keys child) 0 mid) right-keys (subvec (:keys child) (inc mid)) mid-key (get (:keys child) mid) new-node (->Node right-keys (if (:leaf? child) [] (subvec (:children child) (inc mid))) (:leaf? child)) updated-child (assoc child :keys left-keys :children (if (:leaf? child) [] (subvec (:children child) 0 (inc mid))))] (assoc parent :keys (vec (concat (take idx (:keys parent)) [mid-key] (drop idx (:keys parent)))) :children (vec (concat (take idx (:children parent)) [updated-child new-node] (drop (inc idx) (:children parent)))))))
(defn insert-non-full [node key t] (if (:leaf? node) (let [new-keys (vec (sort (conj (:keys node) key)))] (assoc node :keys new-keys)) (let [idx (count (take-while (fn [k] (< k key)) (:keys node))) child (get (:children node) idx) updated-child (if (>= (count (:keys child)) (* 2 t)) (let [split-parent (split-child node idx child t) new-idx (if (> key (get (:keys split-parent) idx)) (inc idx) idx)] (insert-non-full (get (:children split-parent) new-idx) key t)) (insert-non-full child key t))] (assoc node :children (assoc (:children node) idx updated-child)))))
(defn b-tree-insert [btree key] (let [root (:root btree) t (:t btree)] (if (>= (count (:keys root)) (* 2 t)) (let [new-root (->Node [] [root] false) split-root (split-child new-root 0 root t) updated-root (insert-non-full split-root key t)] (assoc btree :root updated-root)) (assoc btree :root (insert-non-full root key t)))))
(defn search-node [node key] (if (nil? node) nil (let [idx (count (take-while (fn [k] (< k key)) (:keys node)))] (cond (and (< idx (count (:keys node))) (= key (get (:keys node) idx))) true (:leaf? node) nil :else (search-node (get (:children node) idx) key)))))
(defn b-tree-search [btree key] (search-node (:root btree) key))
(defn split-node [node t] (let [mid (quot (count (:keys node)) 2) left-keys (subvec (:keys node) 0 mid) right-keys (subvec (:keys node) (inc mid)) mid-key (get (:keys node) mid) left-children (if (:leaf? node) [] (subvec (:children node) 0 (inc mid))) right-children (if (:leaf? node) [] (subvec (:children node) (inc mid))) left-node (->Node left-keys left-children (:leaf? node)) right-node (->Node right-keys right-children (:leaf? node))] {:median mid-key, :right right-node, :left left-node}))