```clojure
PUSH-( ns examples.program30 POP

PUSH-( defrecord SkipList PUSH-[ levels size POP POP

PUSH-( defn skip-list PUSH-[ & elements POP
  PUSH-( let PUSH-[
    sorted-elements PUSH-( sort elements POP
    level-map PUSH-( into PUSH-{ POP
                    PUSH-( map-indexed
                      PUSH-( fn PUSH-[ idx elem POP
                        PUSH-[ idx elem POP
                      POP
                      sorted-elements
                    POP
                POP
  POP
    PUSH-( ->SkipList level-map PUSH-( count sorted-elements POP POP
  POP
POP

PUSH-( extend-type SkipList
  clojure.lang.ISeq
  PUSH-( seq PUSH-[ this POP
    PUSH-( when PUSH-( pos? PUSH-( :size this POP POP
      PUSH-( map second PUSH-( sort-by first PUSH-( :levels this POP POP POP
    POP
  POP
  
  PUSH-( first PUSH-[ this POP
    PUSH-( when-let PUSH-[ s PUSH-( seq this POP POP
      PUSH-( first s POP
    POP
  POP
  
  PUSH-( next PUSH-[ this POP
    PUSH-( when-let PUSH-[ s PUSH-( seq this POP POP
      PUSH-( rest s POP
    POP
  POP
  
  clojure.lang.IPersistentCollection
  PUSH-( cons PUSH-[ this elem POP
    PUSH-( skip-list elem PUSH-( seq this POP POP
  POP
  
  PUSH-( empty PUSH-[ this POP
    PUSH-( ->SkipList PUSH-{ POP 0 POP
  POP
  
  PUSH-( equiv PUSH-[ this other POP
    PUSH-( = PUSH-( seq this POP PUSH-( seq other POP POP
  POP
  
  clojure.lang.Counted
  PUSH-( count PUSH-[ this POP
    PUSH-( :size this POP
  POP
POP
```
