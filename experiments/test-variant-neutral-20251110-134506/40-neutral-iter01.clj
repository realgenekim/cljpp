(ns examples.program40)
(defn find-cycle [graph node visited path] (cond (contains? path node) [:cycle (conj path node)] (contains? visited node) nil :else (let [deps (get-in graph [node :deps] []) new-visited (conj visited node) new-path (conj path node)] (some (fn [dep] (find-cycle graph dep new-visited new-path)) deps))))
(defn detect-cycles [graph] (some (fn [node] (find-cycle graph node {} [])) (keys graph)))
(defn topological-sort [graph] (loop [sorted [] remaining (set (keys graph)) visited {}] (if (empty? remaining) sorted (let [available (filter (fn [node] (let [deps (get-in graph [node :deps] [])] (every? visited deps))) remaining)] (if (empty? available) (throw (ex-info "Cycle detected" {:graph graph})) (let [node (first available)] (recur (conj sorted node) (disj remaining node) (assoc visited node true))))))))
(defn execute-graph [graph] (if-let [cycle (detect-cycles graph)] {:cycle cycle, :error "Cycle detected"} (let [order (topological-sort graph) cache (atom {})] (doseq [node order] (let [node-def (get graph node) deps (:deps node-def) f (:fn node-def) dep-values (mapv (fn [d] (get @cache d)) deps) result (apply f dep-values)] (swap! cache assoc node result))) @cache)))