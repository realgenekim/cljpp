(ns examples.program39)
(defrecord Node [keys children leaf?])
(defn create-node [leaf?] (->Node [] [] leaf?))
(defn create-btree [t] {:root (create-node true), :t t})
(defn split-child [parent idx t] (let [full-child (nth (:children parent) idx) mid (- t 1) new-child (->Node (vec (drop t (:keys full-child))) (if (:leaf? full-child) [] (vec (drop t (:children full-child)))) (:leaf? full-child)) mid-key (nth (:keys full-child) mid) updated-child (->Node (vec (take mid (:keys full-child))) (if (:leaf? full-child) [] (vec (take t (:children full-child)))) (:leaf? full-child))] (->Node (vec (concat (take idx (:keys parent)) [mid-key] (drop idx (:keys parent)))) (vec (concat (take idx (:children parent)) [updated-child new-child] (drop (inc idx) (:children parent)))) (:leaf? parent))))
(defn insert-non-full [node k t] (if (:leaf? node) (let [keys (:keys node) insert-pos (count (take-while (fn [x] (< x k)) keys))] (->Node (vec (concat (take insert-pos keys) [k] (drop insert-pos keys))) [] true)) (let [keys (:keys node) idx (dec (count (take-while (fn [x] (< x k)) keys))) child (nth (:children node) idx)] (if (>= (count (:keys child)) (- (* 2 t) 1)) (let [split-parent (split-child node idx t) new-idx (if (> k (nth (:keys split-parent) idx)) (inc idx) idx)] (->Node (:keys split-parent) (assoc (:children split-parent) new-idx (insert-non-full (nth (:children split-parent) new-idx) k t)) false)) (->Node (:keys node) (assoc (:children node) idx (insert-non-full child k t)) false)))))
(defn b-tree-insert [btree k] (let [root (:root btree) t (:t btree)] (if (>= (count (:keys root)) (- (* 2 t) 1)) (let [new-root (->Node [] [root] false) split-root (split-child new-root 0 t)] {:root (insert-non-full split-root k t), :t t}) {:root (insert-non-full root k t), :t t})))
(defn search-node [node k] (let [keys (:keys node) idx (count (take-while (fn [x] (< x k)) keys))] (cond (and (< idx (count keys)) (= k (nth keys idx))) true (:leaf? node) false :else (search-node (nth (:children node) idx) k))))
(defn b-tree-search [btree k] (search-node (:root btree) k))
(defn split-node [node t] (let [mid (- t 1) left (->Node (vec (take mid (:keys node))) (if (:leaf? node) [] (vec (take t (:children node)))) (:leaf? node)) right (->Node (vec (drop t (:keys node))) (if (:leaf? node) [] (vec (drop t (:children node)))) (:leaf? node)) mid-key (nth (:keys node) mid)] {:mid mid-key, :right right, :left left}))