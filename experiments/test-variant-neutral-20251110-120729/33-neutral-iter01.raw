I'll write a Clojure program for event sourcing with apply-event multimethod, aggregate reducing, and get-state-at-time filtering.

```clojure
PUSH-( ns examples.program33 POP

PUSH-( defmulti apply-event
  PUSH-( fn PUSH-[ state event POP PUSH-( :type event POP POP
POP

PUSH-( defmethod apply-event :user-created
  PUSH-[ state event POP
  PUSH-( assoc state
    :id PUSH-( :user-id event POP
    :name PUSH-( :name event POP
    :email PUSH-( :email event POP
    :created-at PUSH-( :timestamp event POP
  POP
POP

PUSH-( defmethod apply-event :user-updated
  PUSH-[ state event POP
  PUSH-( merge state
    PUSH-( select-keys event PUSH-[ :name :email POP POP
    PUSH-{ :updated-at PUSH-( :timestamp event POP POP
  POP
POP

PUSH-( defmethod apply-event :user-deactivated
  PUSH-[ state event POP
  PUSH-( assoc state
    :active? false
    :deactivated-at PUSH-( :timestamp event POP
  POP
POP

PUSH-( defmethod apply-event :default
  PUSH-[ state event POP
  state
POP

PUSH-( defn aggregate
  PUSH-[ events POP
  PUSH-( reduce apply-event PUSH-{ :active? true POP events POP
POP

PUSH-( defn get-state-at-time
  PUSH-[ events timestamp POP
  PUSH-( ->> events
    PUSH-( filter PUSH-( fn PUSH-[ e POP PUSH-( <= PUSH-( :timestamp e POP timestamp POP POP POP
    PUSH-( aggregate POP
  POP
POP
```
