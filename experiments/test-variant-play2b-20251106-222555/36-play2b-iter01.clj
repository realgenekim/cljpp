(ns examples.program36)
(defn m-return [v] (fn [input] [[v input]]))
(defn m-bind [parser f] (fn [input] (let [result (parser input)] (if (empty? result) [] (let [[[v remaining]] (first result) next-parser (f v)] (next-parser remaining))))))
(def mzero (fn [input] []))
(defn mplus [p1 p2] (fn [input] (let [r1 (p1 input)] (if (seq r1) r1 (p2 input)))))
(defn parse-char [pred] (fn [input] (if (and (seq input) (pred (first input))) [[(first input) (subs input 1)]] [])))
(defn parse-digit [] (parse-char (fn [c] (Character/isDigit c))))
(defn parse-number [] (fn [input] (let [result ((parse-digit) input)] (if (seq result) (let [[[digit rest-input]] (first result) more ((parse-number) rest-input)] (if (seq more) (let [[[num remaining]] (first more)] [[(read-string (str digit num)) remaining]]) [[(read-string (str digit)) rest-input]])) []))))
(defn parse-op [op] (parse-char (fn [c] (= c op))))
(declare parse-expr)
(defn parse-term [] (mplus (parse-number) (parse-expr)))
(defn parse-expr [] (fn [input] (let [left ((parse-term) input)] (if (seq left) (let [[[lval rest1]] (first left) op ((mplus (parse-op \+) (parse-op \-)) rest1)] (if (seq op) (let [[[op-char rest2]] (first op) right ((parse-term) rest2)] (if (seq right) (let [[[rval rest3]] (first right)] [[(if (= op-char \+) (+ lval rval) (- lval rval)) rest3]]) [])) left)) []))))