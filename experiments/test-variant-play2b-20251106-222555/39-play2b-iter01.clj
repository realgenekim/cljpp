(ns examples.program39)
(defrecord Node [keys children leaf?])
(defn create-node [leaf?] (->Node [] [] leaf?))
(defn create-btree [t] {:root (create-node true), :t t})
(defn search-in-node [node key] (let [idx (count (take-while (fn [k] (< k key)) (:keys node)))] (cond (and (< idx (count (:keys node))) (= key (nth (:keys node) idx))) {:found? true, :node node, :idx idx} (:leaf? node) {:found? false} :else (recur (nth (:children node) idx) key))))
(defn b-tree-search [btree key] (search-in-node (:root btree) key))
(defn split-child [parent idx child t] (let [mid-idx (dec t) mid-key (nth (:keys child) mid-idx) left-keys (vec (take mid-idx (:keys child))) right-keys (vec (drop (inc mid-idx) (:keys child))) left-children (when-not (:leaf? child) (vec (take t (:children child)))) right-children (when-not (:leaf? child) (vec (drop t (:children child)))) left-node (->Node left-keys left-children (:leaf? child)) right-node (->Node right-keys right-children (:leaf? child)) new-keys (vec (concat (take idx (:keys parent)) [mid-key] (drop idx (:keys parent)))) new-children (vec (concat (take idx (:children parent)) [left-node right-node] (drop (inc idx) (:children parent))))] (->Node new-keys new-children (:leaf? parent))))
(defn insert-non-full [node key t] (if (:leaf? node) (let [idx (count (take-while (fn [k] (< k key)) (:keys node))) new-keys (vec (concat (take idx (:keys node)) [key] (drop idx (:keys node))))] (assoc node :keys new-keys))))
(let [idx (count (take-while (fn [k] (< k key)) (:keys node))) child (nth (:children node) idx) child-full? (>= (count (:keys child)) (dec (* 2 t)))] (if child-full? (let [new-parent (split-child node idx child t) new-idx (if (< key (nth (:keys new-parent) idx)) idx (inc idx)) new-child (nth (:children new-parent) new-idx) updated-child (insert-non-full new-child key t) new-children (assoc (:children new-parent) new-idx updated-child)] (assoc new-parent :children new-children))))
(let [updated-child (insert-non-full child key t) new-children (assoc (:children node) idx updated-child)] (assoc node :children new-children))
(defn b-tree-insert [btree key] (let [root (:root btree) t (:t btree) root-full? (>= (count (:keys root)) (dec (* 2 t)))] (if root-full? (let [new-root (->Node [] [root] false) split-root (split-child new-root 0 root t) updated-root (insert-non-full split-root key t)] (assoc btree :root updated-root)))))
(let [updated-root (insert-non-full root key t)] (assoc btree :root updated-root))
(defn split-node [node t] (let [mid-idx (dec t) mid-key (nth (:keys node) mid-idx) left-keys (vec (take mid-idx (:keys node))) right-keys (vec (drop (inc mid-idx) (:keys node))) left-children (when (:children node) (vec (take t (:children node)))) right-children (when (:children node) (vec (drop t (:children node)))) left-node (->Node left-keys left-children (:leaf? node)) right-node (->Node right-keys right-children (:leaf? node))] {:mid-key mid-key, :right right-node, :left left-node}))