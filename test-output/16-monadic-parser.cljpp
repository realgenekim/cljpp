PUSH-( ns examples.parser POP

PUSH-( defn return-parser PUSH-[ value POP
  PUSH-( fn PUSH-[ input POP
    PUSH-[ PUSH-{ :value value :remaining input POP POP
  POP
POP

PUSH-( defn bind-parser PUSH-[ parser f POP
  PUSH-( fn PUSH-[ input POP
    PUSH-( let PUSH-[ results PUSH-( parser input POP POP
      PUSH-( mapcat PUSH-( fn PUSH-[ r POP
                    PUSH-( let PUSH-[ next-parser PUSH-( f PUSH-( :value r POP POP POP
                      PUSH-( next-parser PUSH-( :remaining r POP POP
                    POP
                  POP
                  results
      POP
    POP
  POP
POP

PUSH-( defn char-parser PUSH-[ c POP
  PUSH-( fn PUSH-[ input POP
    PUSH-( if PUSH-( and PUSH-( seq input POP PUSH-( = c PUSH-( first input POP POP POP
      PUSH-[ PUSH-{ :value c :remaining PUSH-( rest input POP POP POP
      PUSH-[ POP
    POP
  POP
POP

PUSH-( defn or-parser PUSH-[ p1 p2 POP
  PUSH-( fn PUSH-( input POP
    PUSH-( let PUSH-[ r1 PUSH-( p1 input POP
              r2 PUSH-( p2 input POP
    POP
      PUSH-( concat r1 r2 POP
    POP
  POP
POP

PUSH-( defn many-parser PUSH-[ p POP
  PUSH-( fn many-fn PUSH-[ input POP
    PUSH-( let PUSH-[ first-results PUSH-( p input POP POP
      PUSH-( if PUSH-( empty? first-results POP
        PUSH-[ PUSH-{ :value PUSH-[ POP :remaining input POP POP
        PUSH-( mapcat PUSH-( fn PUSH-[ r POP
                      PUSH-( let PUSH-[ rest-results PUSH-( many-fn PUSH-( :remaining r POP POP POP
                        PUSH-( map PUSH-( fn PUSH-[ rr POP
                                   PUSH-{ :value PUSH-( cons PUSH-( :value r POP PUSH-( :value rr POP POP
                                      :remaining PUSH-( :remaining rr POP
                                   POP
                                 POP
                                 rest-results
                        POP
                      POP
                    POP
                    first-results
        POP
      POP
    POP
  POP
POP
